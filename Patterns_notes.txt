////////////////////////////////////////////// Singleton ///////////////////////////////////////////////////////////////
Singleton (Одиночка) - паттерн проектирования, гарантирующий, что у класса будет только один экземпляр,
обычно используется для класса Repository, который работает с данными и важно чтобы данные во всей программе были одинаковыми
Самая простая реализация - object (без конструкторов) - можно использовать, когда для создания объекта не нужно ничего передавать в качестве параметра
Если все же нужно передавать объекты, тогда нужно использовать этот паттерн, чтобы запретить снаружи экземпляры этого класса

Класс - это шаблон, по которому строится объект.
Все свойства и методы, которые объявлены внутри относятся к экземплярам этого класса.

companion object { } - внутри могут находиться переменные и методы,
Все, что находится внутри уже, относится именно к КЛАССУ
Обращаться к к нему можно через сам Класс

////////////////////////////////////////////// Observer (Наблюдатель) ////////////////////////////////////////////////////////////////
В Kotlin Observer — это паттерн проектирования, который позволяет объекту (называемому subject или observable)
уведомлять другие объекты (observers или listeners) об изменениях своего состояния.

//////////////////////////////////////////// Command (Команда) ////////////////////////////////////////////////////////
представляет собой задачу которую надо выполнить - Интерфейс с одним методом
можно реализовать через лямбда-выражение или создавая экземпляр интерфейсного типа (указать функциональный интерфейс (fun)).
Принцип паттерна, что команды - это объекты, эти команды мы отдаем классу, который умеет их обрабатывать,
тем самым мы разделяем ответственность каждого класса.

////////////////////////////////////////////// Builder (Строитель) ////////////////////////////////////////////////////////////////
Builder — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово.
Особенно полезен, когда объект имеет много полей или требует сложной логики инициализации.

//////////////////////////////////////////// lateinit var //////////////////////////////////////////////////////////////
Т.е. по сути lateinit - обычная var переменная, ей можно присваивать значение в любой момент и сколько угодно раз.
Отличие от обычной var переменной, что если вы сразу не можете положить в нее значение,
то ее нужно делать нулабельной и присваивать null, а во всех местах, где есть обращение к ней добавлять безопасный или небезопасный вызов.
А lateinit всегда ненулабельная и есть возможность словить NPE, если забыли присвоить ей значение

//////////////////////////////////////////// fun interface (функциональный Интерфейс) //////////////////////////////////
Должен иметь ровно один метод
Можно передавать реализацию такого метода с помощью лямбда выражения.
Реализуется 3 способами:
    1. Создать класс, реализующий интерфейс и передать экземпляр этого класса
    2. Создать экземпляр анонимного класса
    3. При помощи лямбда выражения

//////////////////////////////////////////// sealed interface (запечатанный) //////////////////////////////////////////////////////////////
Позволяют ограничить иерархию наследования
Все реализации такого интерфейса должны находиться в том же пакете, что и сам интерфейс
Обычно все реализации объявляют внутри самого sealed интерфейса